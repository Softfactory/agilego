# Step 1. 테스트가 Dollar를 창조하다.

## 태초에 테스트가 있다.   

우리는 이제 TDD 사용해서 앞으로 나아가려 합니다.
시작을 하기전에 알아야 할 것이 있습니다.  
GO에서 테스트케이스를 작성하는데 필요한 테스트 규칙이겠죠.

우선 GO의 모든 테스트 파일은 테스트할 소스 파일명 뒤에 `_test` 가 붙어야 합니다.
즉, 이글처럼 `money.go` 의 테스트 케이스는 모두 `money_test.go` 파일에 들어가야 합니다.

또한 테스트 패키지를 포함하겠다고 선언해야 합니다.

```go
import (
	"testing"
)
```

테스트 케이스는 함수로 작성합니다. 대문자 T로 시작되는 Test* 함수가 테스트 케이스입니다.
그리고 testing.T 구조체를 인자로 받습니다.

```go
func TestMultiplication(t *testing.T) {

}
```

테스트 실행은 아주 간단합니다.
쉘에서 소스코드가 있는 폴더로 이동합니다.

```
$ go test
```

테스팅 패키지 사용법과 관련 기법은 이 글 전반에 걸쳐서 조금씩 설명하면서 진행합니다.
이제 본격적으로 우리가 하고자 하는 작업에 대해서 이야기할 수 있습니다.

## Dollar를 창조하다.

### Money 패키지

Money에 대한 기능을 먼저 정의해야 할 시점입니다.
저는 TDD를 거의 Agile 관점에서 생각합니다. (물론 여러분이 비판을 하더라도 전 고집을 꺽을 생각이 없습니다.)
Agile 방법론에서는 우선 개발해야 할 대상을 사용자 스토리로 정의합니다.
사용자 스토리가 명확해진 다음에 개발 단계로 들어갈 수가 있습니다.
제 경험상 가장 좋은 사용자 스토리는 실사용자가 참여한 사용자 매뉴얼 수준의 스토리입니다.

저는 대략 다음과 같은 내용이 스토리 상에 포함될 것이라고 가정합니다.

> 사용자A는 가상의 거래 시스템을 이용해서 다중 통화의 가중평균을 구할 수 있다.

> 가중평균을 구하기 위해 통화는 더하기 및 곱하기 연산을 지원해야 한다.

> 거래 주식수에 주식의 가격을 곱하여 총 금액을 얻을 수 있어야 한다.

대략이라고 한 이유는 테스트 주도 개발을 진행하다 보면 실제 할당된 스토리에 내용을
추가해야 할 필요가 발생하기 때문입니다.

### 실패하는 테스트 작성

실패를 두려워하면 성공도 없다고 합니다. 일상에서는 그래 그렇지하고 고개를 끄덕이면 되지만  
테스트 주도 개발에서 이 말은 반드시 지켜야 할 일종의 수행 원칙으로 변경됩니다.

앞에서 언급한 스토리 내용을 좀더 깔끔한(?) 형식으로 변경하면 다음과 같습니다.

> **TODO**

> $5 + 5000원 = $10 (1:1000 환율일때 )

> $5 x 2 = $10

먼저 Dollar 사용하는 곱셈연산으로  실패하는 테스트 케이스를 작성합니다.
아래 이름으로 파일 2개를 만듭니다. `package main`이 내용으로 맨 위에 들어가야 합니다.

* money.go
* money_test.go

money_test 에는 우리가 구현하고자 하는 코드에 대한 테스트 내용이 먼저 들어갑니다.

```go
import (
	"testing"
)

// TODO : $5x2=$10
func TestMultiplication(t *testing.T) {

	var five = Dollar{5}
	five.times(2)
	if five.amount != 10 {
		t.Errorf("Amount is expected 10, but actually %d ", five.amount)
	}
}
```
> **TODO**

> $5 + 5000원 = $10 (1:1000 환율일때 )

> <b>$5 x 2 = $10</b>

굵은 글씨는 우리가 현재 진행하는 작업입니다. 위의 코드를 테스트 (`go test`) 하면 테스트가 `[build failed]` 를 반환합니다.

```
./money_test.go:14: undefined: Dollar
FAIL	AgileGO/money [build failed]
```

### 창조는 테스트로부터

우리는 테스트가 실패한다는 사실로부터 Dollar 클래스가 필요함을 알았습니다.
그런데 GO는 객체지향 언어가 아닙니다. 그래서 Dollar를 구조체로 표현합니다.

```
type Dollar struct {
    amount int
}
```

이를 money.go에 추가하고 저장하는 순간 경고가 발생합니다.
```
exported type Dollar should have comment or be unexported
```
내용을 해석하면 외부에 노출된 타입인데 주석을 달던지 아니면 숨기라는 경고입니다.
우리는 컴파일러의 경고를 무시할 만큼 용감하지 않습니다. 주석을 달아야 할 것 같습니다.

```
// dollar 클래스
type Dollar struct {
    ...
}
```

money.go 파일을 저장하면 아쉽지만 새로운 경고가 나타납니다.

```
comment on exported type Dollar should be of the form "Dollar ..." (with optional leading article)
```
컴파일러가 알려주길 주석이 잘못되어 있다고 합니다. Go는 Documentation이 강력하면서도 철저한 규칙을 가지고 있습니다.
문서화 방법에 대해서는 나중에 자세히 설명하도록 하고 여기서는 주석을 아래와 같이 바꿉니다.

```
// Dollar 클래스는 Dollar 통화를 나타냅니다.
```

그럼에도 테스트는 여전히 `[build failed]` 를 반환합니다.

```
./money_test.go:15: five.times undefined (type Dollar has no field or method times)
FAIL	AgileGO/money [build failed]
```

times를 정의하지 않았다는 군요. 컴파일러의 지시에 따라 times를 정의합니다.

```go
func (dollar *Dollar) times(multiplier int) {

}
```

GO에서는 구조체에 메소드를 연결하는 방법이 두 가지가 있습니다.
구조체의 포인터를 리시버로 받는 방법과 일반 구조체를 받는 방법입니다. 두 방법 모두
`func (리시버) 메소드명(인수) 반환값 {} ` 구조입니다.

함수 내용이 이상하게 보이겠지만 여기서는 이 정도로 충분합니다.
이제 컴파일 문제는 없습니다. 우리에게 잔소리하던 `[build failed]`는 사라졌습니다.
하지만 테스트는 여전히 실패입니다. 사실 지금의 실패는 의도된 것입니다. 코드를 성장시키 위해서는 아래의 원칙을 지켜야 합니다.

> **원칙1**

> 실패하는 테스트를 작성해서 성장하는 코드를 작성한다.

실패하는 테스트를 작성하기까지 우리는 2단계를 거쳤습니다.

무엇보다 우선 테스트를 작성하였습니다. 이때 컴파일러의 잔소리를 들었습니다.
두번째 단계로 컴파일러가 더이상 잔소리하지 못하게 우선 컴파일만 되도록 죄(?)를 짓는 코드를 작성했습니다.
이런 죄로 인해서 테스트는 실패했습니다.

테스트 주도 개발에서는 이 단계를 건너뛰지 말고 수행해야 합니다.

## 작업의 끝

이제 테스트를 성공시켜서 이번 작업(`$5 x 2 = $10`)을 끝내려 합니다.

```go
 dollar.amount = dollar.amount * multiplier
```
테스트가 성공합니다. 그런데 테스트 케이스가 표시되지 않아서 구체적인 내용을 알고 싶습니다.  
아래와 같이 `-v` 을 주면 상세한 테스트 결과를 얻을 수 있습니다.

```
go test -v
=== RUN   TestMultiplication
--- PASS: TestMultiplication (0.00s)
PASS
ok  	AgileGO/money	0.001s
```

이제 작업을 마무리 해야 합니다. 테스트의 주석을 아래와 같이 변경합니다.

```go
// FIXED : $5x2=$10
```
> **TODO**

> $5 + 5000원 = $10 (1:1000 환율일때 )

> <s>$5 x 2 = $10</s>

할일 목록에서 둘째줄을 지웠습니다. 이제 다음 작업을 하기전에 이번 장을 되짚어 봅시다.

### 번거로운 테스트가 필요한 이유

실제 소스 코드가 매우 간단해서 이렇게 번거로운 테스트를 거쳐야 하는 것인지 의문이 들수 있습니다.
작성자의 지능지수를 의심해 볼 여지도 있습니다.
분명히 말씀드리면 이런 의견을 저도 현장에서 수없이 들었습니다. 특히나 전자정부프레임워크 같은
자바 프레임워크의 DTO(Data Transfer Object)들은 이런 지적에 대해서 저를 난감하게 하기도 했습니다.
그럼에도 불구하고 실제 테스트 주도 개발을 적용한 결과는 매우 달랐습니다.
이렇게 작성한 코드는 누구에게 보여줘도 안전한 코드가 되었습니다.
제가 참여했던 어떤 차세대 프로젝트에서 16개 시스템이 동시에 오픈하는 날 정시에 퇴근한 팀은 우리팀이 유일했습니다.

더구나 GO를 처음 개발하는 우리는 테스트를 하면서 코드 작성보다는 언어의 핵심적인 문법을 알게 되었습니다.

## 테스트를 통해 알게된 것

### 테스트도 설계의 일부

테스트 케이스를 작성하면서 구조체, 메소드의 이름을 지정했습니다. 사실 일부 방법론에서
외부에 노출되는 클래스나 메소드명 뿐만 아니라 내부에 선언되는 메소드명까지 설계서에 정의되어야 한다고 주장합니다.
이런 방법론을 따른 설계서의 내용은 정말 방대합니다. 코딩 규칙만 제공해주는 방식과는 절대적인 양에서 차이가 납니다.  
사실 이런 주장을 하는 사람들은 코딩도 설계의 일부라는 것을 모르고 있다고 생각합니다.
아니 알고 있다고 하더라도 그것이 설계자의 영역으로 생각하는 것 같습니다.
제 생각에 이 부분은 개발자에게 아키텍트가 양보해야 하는 역할입니다.

> "소스코드는 설계다."
[Reeves, 1992](http://www.bleading-edge.com/Publications/C++Journal/Cpjour2.htm)

### 구조체의 메소드 연결

구조체에 메소드 연결을 위해 리시버를 정의할 때 두 가지 방법이 있습니다.
`리시버명 *구조체` 와 `리시버명 구조체` 는 정의하고자 하는 메소드의 용도에 따라 구분되어 사용됩니다.
구조체의 포인터를 리시버로 받는 방법은 원래의 구조체를 변경할 수 있습니다.
일반 구조체를 받게 되면 구조체는 값이 그대로 복사되어서 구조체의 필드를 변경해도 원래 값은 변경되지 않습니다.
이를 지금 테스트해 보실 수 있습니다. 우리가 작성한 함수에서 리시버를 일반 구조체로 변경하고 테스트를 수행하면
테스트가 실패로 끝납니다.

### GO에는 Assertion이 없다.

GO 언어 설계자들은 Assert 구문을 제공하는 것은 개발자들에게 Exception을 무시하고 코딩할 자유를 주는 것이라고 생각했습니다.
자세한 내용은 [구글 FAQ](https://golang.org/doc/faq#assertions) 를 참조하면 됩니다.

### 구조체 선언하기

GO 에서 구조체는 `type 구조체명 struct { }` 형식으로 작성해야 합니다.
저는 `java` 에 익숙한 사람이라서 GO 에서  public 과 private 을 찾기 위해 구글링을 했습니다.
결과적으로 찾을 수가 없었죠. 이유는 GO는 다른 개념을 가지고 있기 때문입니다.
'exported'와 'unexported' 멤버라는 정의만 있습니다. 이 부분은 다음 장에서 설명할 것입니다.

### GO 문서화

문서화된 결과를 즉시 보고 싶을 때도 있습니다. `godoc` 명령어가 바로 그런 역할을 해줍니다.

```
godoc AgileGO/money
```

우리가 의도한 대로 문서가 보이냐고 물어본다면 저는 여러분을 함정에 빠트린 것입니다.
앞에서 우리는 파일명과 다르게 패키지 명을 정의했습니다.
사실 `main`은 실행 명령어를 위한 특별한 패키지명입니다.
그래서 `godoc` 은 이런 경우 패키지 내부에 있는 내용을 출력할 필요가 없다고 판단합니다.   

추가로 `Dollar` 구조체 안에 amount는 보이지 않습니다. 'unexported' 필드이기 때문입니다.
저는 이런 식으로 `godoc` 도 테스트해서 기능을 추적해가며 익혔습니다.

'unexported' 필드까지 자세히 보려면 `-src` 가 필요합니다.
```
godoc -src [패키지명] [구조체 또는 메소드]
```

좀더 상세한 내용을 빨리 알고 싶다면 아래 두 웹페이지를 보시기 바랍니다.
* [Godoc 블로그](http://blog.golang.org/godoc-documenting-go-code)
* [Godoc 홈페이지](https://godoc.org/golang.org/x/tools/cmd/godoc)
